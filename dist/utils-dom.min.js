function ready(callback) {
    if (document.readyState !== 'loading') {
        callback();
    } else {
        document.addEventListener('DOMContentLoaded', function () {
            callback();
        });
    }
}

(function () {
    window.KEY_BACKSPACE = 8;
    window.KEY_TAB = 9;
    window.KEY_ENTER = 13;
    window.KEY_SHIFT = 16;
    window.KEY_CTRL = 17;
    window.KEY_ALT = 18;
    window.KEY_ESCAPE = 27;
    window.KEY_SPACE = 32;
    window.KEY_PAGE_UP = 33;
    window.KEY_PAGE_DOWN = 34;
    window.KEY_ARROW_LEFT = 37;
    window.KEY_ARROW_UP = 38;
    window.KEY_ARROW_RIGHT = 39;
    window.KEY_ARROW_DOWN = 40;
    window.KEY_DELETE = 46;
})();

//import {BunnyElement} from "../../BunnyElement";

/**
 * Adds event listener to element and stores a function in this element's custom property
 * and returns unique ID which can be used to remove event listener later
 * even anonymous functions, component methods, functions with arguments
 *
 * Simple example:
 *
 * const Component = {
 *      docBodyClickEventId: null,
 *      anonymousEventId: null,
 *
 *      init(param1, param2) {
 *          this.docBodyClickEventId = addEvent(document.body, 'click', this.bodyClicked.bind(this, param1, param2));
 *
 *          this.anonymousEventId = addEvent(document.body, 'click', e => {
 *              console.log(e)
 *          });
 *      },
 *
 *      destroy() {
 *          this.docBodyClickEventId = removeEvent(document.body, 'click', this.docBodyClickEventId);
 *
 *          this.anonymousEventId = removeEvent(document.body, 'click', this.anonymousEventId)'
 *      },
 *
 *      bodyClicked(param1, param2) {
 *          console.log(this.internalAction(param1, param2));
 *      },
 *
 *      internalAction(param1, param2) {
 *          return param1 + param2;
 *      }
 * }
 *
 * @param {HTMLElement} element
 * @param {String} eventName
 * @param {Function} eventListener
 *
 * @returns {Number}
 */
function addEvent(element, eventName, eventListener) {
  if (element.__bunny_event_handlers === undefined) {
    element.__bunny_event_handlers = {
      handlers: {},
      counter: 0
    };
  }
  element.__bunny_event_handlers.handlers[element.__bunny_event_handlers.counter] = eventListener;
  element.addEventListener(eventName, element.__bunny_event_handlers.handlers[element.__bunny_event_handlers.counter]);
  element.__bunny_event_handlers.counter++;
  return element.__bunny_event_handlers.counter - 1;
}

/**
 * Remove event listener
 *
 * @param {HTMLElement} element
 * @param {String} eventName
 * @param {Number} eventIndex
 *
 * @returns {null}
 */
function removeEvent(element, eventName, eventIndex) {
  if (element.__bunny_event_handlers !== undefined && element.__bunny_event_handlers.handlers[eventIndex] !== undefined) {
    element.removeEventListener(eventName, element.__bunny_event_handlers.handlers[eventIndex]);
    delete element.__bunny_event_handlers.handlers[eventIndex];
    // do not decrement counter, each new event handler should have next unique index
  }
  return null;
}

/**
 * Call event listener only once after "delay" ms
 * Useful for scroll, keydown and other events
 * when the actions must be done only once
 * when user stopped typing or scrolling for example
 *
 * @param {HTMLElement} element
 * @param {String} eventName
 * @param {Function} eventListener
 * @param {Number} delay
 * @returns {Number}
 */
function addEventOnce(element, eventName, eventListener) {
  var delay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 500;

  var timeout = 0;
  return addEvent(element, eventName, function (e) {
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      eventListener(e);
    }, delay);
  });
}

function isEventCursorInside(e, element) {
  var bounds = element.getBoundingClientRect();
  return e.clientX > bounds.left && e.clientX < bounds.right && e.clientY > bounds.top && e.clientY < bounds.bottom;
}

function onClickOutside(element, callback) {
  if (document.__bunny_core_outside_callbacks === undefined) {
    document.__bunny_core_outside_callbacks = [];
  }
  var handler = function handler(event) {
    var target = event.target;
    var bTargetExists = document.contains(target) !== false;
    var bTargetIsElOrChild = event.target === element || element.contains(event.target);
    if (bTargetExists && !bTargetIsElOrChild) {
      callback(event);
    }
  };

  if (element.__bunny_core_outside_callbacks === undefined) {
    element.__bunny_core_outside_callbacks = [];
  }
  element.__bunny_core_outside_callbacks.push(handler);
  document.__bunny_core_outside_callbacks.push(handler);

  if (document.__bunny_core_outside_handler === undefined) {
    document.__bunny_core_outside_handler = function (event) {
      document.__bunny_core_outside_callbacks.forEach(function (callback) {
        callback(event);
      });
    };
    document.addEventListener('click', document.__bunny_core_outside_handler);
    document.addEventListener('touchstart', document.__bunny_core_outside_handler);
  }

  return handler;
}

function removeClickOutside(element, callback) {
  if (document.__bunny_core_outside_callbacks !== undefined) {
    var index = document.__bunny_core_outside_callbacks.indexOf(callback);
    if (index !== -1) {
      document.__bunny_core_outside_callbacks.splice(index, 1);
      if (document.__bunny_core_outside_callbacks.length === 0) {
        document.removeEventListener('click', document.__bunny_core_outside_handler);
        document.removeEventListener('touchstart', document.__bunny_core_outside_handler);
        delete document.__bunny_core_outside_handler;
      }
    }
  }

  if (element.__bunny_core_outside_callbacks !== undefined) {
    var _index = element.__bunny_core_outside_callbacks.indexOf(callback);
    if (_index !== -1) {
      element.__bunny_core_outside_callbacks.splice(_index, 1);
    }
  }
}

/**
 * Adds up, down, esc, enter keypress event on 'element' to traverse though 'items'
 *
 * @param {HTMLElement} element
 * @param {HTMLCollection|NodeList} items
 * @param {function} itemSelectCallback
 *   callback(null) if Enter was pressed and no item was selected (for example custom value entered)
 *   callback(false) if Esc was pressed (canceled)
 *   callback({HTMLElement} item) - selected item on Enter
 * @param {function} itemSwitchCallback = null
 *   callback({HTMLElement} item) - new item on arrow up/down
 *
 * @returns {function(*)}
 */
function addEventKeyNavigation(element, items, itemSelectCallback) {
  var itemSwitchCallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;


  var currentItemIndex = null;
  for (var k = 0; k < items.length; k++) {
    if (items[k].hasAttribute('aria-selected')) {
      currentItemIndex = k;
      break;
    }
  }

  /*let currentActiveItems = [];
  for (let k = 0; k < items.length; k++) {
    if (items[k].classList.contains(activeClass)) {
      currentActiveItems.push(items[k]);
    }
  }*/

  var _itemAdd = function _itemAdd() {
    items[currentItemIndex].focus();
    //items[currentItemIndex].classList.add(activeClass);
    //items[currentItemIndex].setAttribute('aria-selected', 'true');
    /*if (!BunnyElement.isInViewport(items[currentItemIndex])) {
      BunnyElement.scrollTo(items[currentItemIndex], 400, -200);
    }*/
    //items[currentItemIndex].scrollIntoView(false);
    if (itemSwitchCallback !== null) {
      itemSwitchCallback(items[currentItemIndex]);
    }
  };

  var _itemRemove = function _itemRemove() {
    //items[currentItemIndex].classList.remove(activeClass);
    //items[currentItemIndex].removeAttribute('aria-selected');
  };

  var handler = function handler(e) {
    var c = e.keyCode;

    var maxItemIndex = items.length - 1;

    if (c === KEY_ENTER || c === KEY_SPACE) {
      e.preventDefault();
      if (currentItemIndex !== null) {
        items[currentItemIndex].click();
        itemSelectCallback(items[currentItemIndex]);
      } else {
        itemSelectCallback(null);
      }
    } else if (c === KEY_ESCAPE) {
      e.preventDefault();
      /*for (let k = 0; k < items.length; k++) {
        if (currentActiveItems.indexOf(items[k]) === -1) {
          // remove active state
          items[k].classList.remove(activeClass);
          items[k].removeAttribute('aria-selected');
        } else {
          // set active state
          items[k].classList.add(activeClass);
          items[k].setAttribute('aria-selected', 'true');
        }
      }*/
      itemSelectCallback(false);
    } else if (c === KEY_ARROW_UP || c === KEY_ARROW_LEFT) {
      e.preventDefault();
      if (currentItemIndex !== null && currentItemIndex > 0) {
        _itemRemove();
        currentItemIndex -= 1;
        _itemAdd();
      }
    } else if (c === KEY_ARROW_DOWN || c === KEY_ARROW_RIGHT) {
      e.preventDefault();
      if (currentItemIndex === null) {
        currentItemIndex = 0;
        _itemAdd();
      } else if (currentItemIndex < maxItemIndex) {
        _itemRemove();
        currentItemIndex += 1;
        _itemAdd();
      }
    }
  };

  if (items.length > 0) {
    element.addEventListener('keydown', handler);
  }

  return handler;
}

function removeEventKeyNavigation(element, handler) {
  element.removeEventListener('keydown', handler);
}

function htmlToNode(html) {
  var e = document.createElement('div');
  e.innerHTML = html;
  return e.firstElementChild;
}

function appendHtml(parent, html) {
  parent.appendChild(htmlToNode(html));
}

/**
 * Parses <template> contents by ID and replaces all {{ var }} inside
 * Second param should be an object of var keys => var values
 * If second params is an Array of Objects, returns DocumentFragment
 * Else - Node
 *
 * @param {String} id
 * @param {Object|Array} data
 * @returns {Node|DocumentFragment} node
 */
function parseTemplate(id, data) {
  var node = null;
  var template = document.getElementById(id);
  var tpl = template.content.firstElementChild.outerHTML;

  var getDataByPath = function getDataByPath(obj, path) {
    var parts = path.split('.');
    var cur = obj;
    for (var k = 0; k < parts.length; k++) {
      var part = parts[k];
      if (cur[part] === undefined) {
        return null;
      } else if (cur[part] === null || cur[part].length === 0) {
        return '';
      } else {
        cur = cur[part];
      }
    }
    return cur;
  };

  var parseRow = function parseRow(originalTpl, rowData) {
    var newTpl = originalTpl;
    newTpl = newTpl.replace(/{{ ([a-zA-Z0-9\-._]*) }}/g, function (match, capture) {
      var res = getDataByPath(rowData, capture);
      return res === null ? match : res;
    });

    var node = htmlToNode(newTpl);
    if (node.tagName === 'TABLE') {
      node = node.rows[0];
    }

    if (template._handlers !== undefined) {
      for (var handlerName in template._handlers) {
        var el = node.querySelector('[handler="' + handlerName + '"]');
        template._handlers[handlerName](el);
      }
    }

    return node;
  };

  if (Array.isArray(data)) {
    node = document.createDocumentFragment();
    data.forEach(function (row) {
      node.appendChild(parseRow(tpl, row));
    });
  } else {
    node = parseRow(tpl, data);
  }

  return node;
}

function registerTemplateHandlers(id, handlers) {
  var tpl = document.getElementById(id);
  if (tpl._handlers === undefined) {
    tpl._handlers = {};
  }
  Object.assign(tpl._handlers, handlers);
}

function makeAccessible(element) {
  var tabIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var role = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'button';

  element.setAttribute('tabindex', tabIndex);
  element.setAttribute('role', role);
  element.addEventListener('keydown', function (e) {
    if (e.keyCode === KEY_ENTER || e.keyCode === KEY_SPACE) {
      element.click();
    }
  });
}

function isElementInside(parentElement, childElement) {
  var x = childElement;
  while (x = x.parentElement) {
    if (x === parentElement) return true;
  }
  return false;
}

