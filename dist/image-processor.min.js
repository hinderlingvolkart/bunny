
var ImageProcessorConfig = {
  tagName: 'imageprocessor',
  tagNameCursor: 'imagecursor',
  selectorBtnSave: '[pid="save"]',
  selectorBtnRotate: '[pid="rotate"]',
  attrQuality: 'quality',
  defaultQuality: 0.7,
  attrOutputSize: 'outputsize',
  defaultOutputSize: '300'
};

var ImageProcessorUI = {

  Config: ImageProcessorConfig,

  getAll: function getAll() {
    var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;

    return container.getElementsByTagName(this.Config.tagName);
  },
  getImage: function getImage(processor) {
    if (processor.__img === undefined) {
      processor.__img = processor.getElementsByTagName('img')[0] || false;
    }
    return processor.__img;
  },
  getCursor: function getCursor(processor) {
    if (processor.__cursor === undefined) {
      processor.__cursor = processor.getElementsByTagName(this.Config.tagNameCursor)[0] || false;
    }
    return processor.__cursor;
  },
  getSaveBtn: function getSaveBtn(processor) {
    return processor.querySelector(this.Config.selectorBtnSave) || false;
  },
  getRotateBtn: function getRotateBtn(processor) {
    return processor.querySelector(this.Config.selectorBtnSave) || false;
  },
  checkCursorWillBeInsideX: function checkCursorWillBeInsideX(processor, newX) {
    var cursor = this.getCursor(processor);
    var img = this.getImage(processor);
    return newX >= 0 && cursor.getBoundingClientRect().width + newX <= img.getBoundingClientRect().width;
  },
  checkCursorWillBeInsideY: function checkCursorWillBeInsideY(processor, newY) {
    var cursor = this.getCursor(processor);
    var img = this.getImage(processor);
    return newY >= 0 && cursor.getBoundingClientRect().height + newY <= img.getBoundingClientRect().height;
  },


  /**
   * Automatically center a cursor taking full images's smallest side length
   */
  centerCursor: function centerCursor(processor) {
    var img = this.getImage(processor);
    var cursor = this.getCursor(processor);
    var size = 0;
    var imgrect = img.getBoundingClientRect();
    if (imgrect.width > imgrect.height) {
      size = imgrect.height;
      cursor.style.left = (imgrect.width - size) / 2 + 'px';
      cursor.style.top = 0 + 'px';
    } else {
      size = imgrect.width;
      cursor.style.left = 0 + 'px';
      cursor.style.top = (imgrect.height - size) / 2 + 'px';
    }
    cursor.style.width = size + 'px';
    cursor.style.height = size + 'px';
  },
  moveCursor: function moveCursor(processor, deltaX, deltaY) {
    var img = this.getImage(processor);
    var cursor = this.getCursor(processor);
    var imgrect = img.getBoundingClientRect();
    var cursorrect = cursor.getBoundingClientRect();

    if (this.checkCursorWillBeInsideX(processor, cursor.offsetLeft + deltaX)) {
      cursor.style.left = cursor.offsetLeft + deltaX + 'px';
    } else if (cursor.offsetLeft + deltaX < 0) {
      cursor.style.left = '0px';
    } else {
      cursor.style.left = imgrect.width - cursorrect.width;
    }

    if (this.checkCursorWillBeInsideY(processor, cursor.offsetTop + deltaY)) {
      cursor.style.top = cursor.offsetTop + deltaY + 'px';
    } else if (cursor.offsetTop + deltaY < 0) {
      cursor.style.top = '0px';
    } else {
      cursor.style.top = imgrect.height - cursorrect.height;
    }
  },
  resizeCursor: function resizeCursor(processor, deltaX) {
    var deltaY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    var img = this.getImage(processor);
    var cursor = this.getCursor(processor);
    var imgrect = img.getBoundingClientRect();
    var cursorrect = cursor.getBoundingClientRect();

    var width = cursorrect.width + deltaX;
    var height = 0;
    if (deltaY === null) {
      height = cursorrect.height + deltaX;
    } else {
      height = cursorrect.height + deltaY;
    }

    if (cursor.offsetTop + height <= imgrect.height && cursor.offsetLeft + width <= imgrect.width) {
      cursor.style.width = width + 'px';
      cursor.style.height = height + 'px';
      return true;
    }
    return false;
  }
};

var ImageProcessor = {

  Config: ImageProcessorConfig,
  UI: ImageProcessorUI,

  init: function init(processor) {
    var src = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var onSave = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    if (src !== null) {
      this.setImage(processor, src);
    }

    this.addEvents(processor);

    if (onSave !== null) {
      this.onSave(processor, onSave);
    }
  },
  deinit: function deinit(processor) {
    this.removeEvents(processor);
    delete processor.__on_save;
  },
  initAll: function initAll() {
    var _this = this;

    var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;

    [].forEach.call(this.UI.getAll(container), function (processor) {
      _this.init(processor);
    });
  },
  deinitAll: function deinitAll() {
    var _this2 = this;

    var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;

    [].forEach.call(this.UI.getAll(container), function (processor) {
      _this2.deinit(processor);
    });
  },
  addEvents: function addEvents(processor) {
    var cursor = this.UI.getCursor(processor);
    var img = this.UI.getImage(processor);
    var saveBtn = this.UI.getSaveBtn(processor);
    processor.__move_start = addEvent(cursor, 'mousedown', this.handleBeginMove.bind(this, processor));
    processor.__move_end = addEvent(window, 'mouseup', this.handleEndMove.bind(this, processor));
    processor.__zoom = addEvent(processor, 'wheel', this.handleZoom.bind(this, processor));
    processor.__save = addEvent(saveBtn, 'click', this.handleSave.bind(this, processor));
    processor.__img_load = addEvent(img, 'load', this.handleImgLoad.bind(this, processor));
    processor.__keypress = addEvent(cursor, 'keypress', this.handleKeyPress.bind(this, processor));
  },
  removeEvents: function removeEvents(processor) {
    var cursor = this.UI.getCursor(processor);
    var img = this.UI.getImage(processor);
    var saveBtn = this.UI.getSaveBtn(processor);
    delete removeEvent(cursor, 'mousedown', processor.__move_start);
    delete removeEvent(window, 'mouseup', processor.__move_end);
    delete removeEvent(processor, 'wheel', processor.__zoom);
    delete removeEvent(saveBtn, 'click', processor.__save);
    delete removeEvent(img, 'load', processor.__img_load);
    delete removeEvent(cursor, 'keypress', processor.__keypress);
  },
  handleKeyPress: function handleKeyPress(processor, e) {
    e.preventDefault();
    if (processor.__key_speed === undefined) {
      processor.__key_speed = 0;
    }
    processor.__key_speed++;
    if (processor.__key_timeout !== undefined) {
      clearTimeout(processor.__key_timeout);
    }
    processor.__key_timeout = setTimeout(function () {
      delete processor.__key_speed;
      delete processor.__key_timeout;
    }, 100);

    if (e.keyCode === KEY_ARROW_RIGHT) {
      if (e.shiftKey) {
        this.UI.resizeCursor(processor, processor.__key_speed);
      } else {
        this.UI.moveCursor(processor, processor.__key_speed, 0);
      }
    } else if (e.keyCode === KEY_ARROW_DOWN) {
      if (e.shiftKey) {
        this.UI.resizeCursor(processor, -processor.__key_speed);
      } else {
        this.UI.moveCursor(processor, 0, processor.__key_speed);
      }
    } else if (e.keyCode === KEY_ARROW_LEFT) {
      if (e.shiftKey) {
        this.UI.resizeCursor(processor, -processor.__key_speed);
      } else {
        this.UI.moveCursor(processor, -processor.__key_speed, 0);
      }
    } else if (e.keyCode === KEY_ARROW_UP) {
      if (e.shiftKey) {
        this.UI.resizeCursor(processor, processor.__key_speed);
      } else {
        this.UI.moveCursor(processor, 0, -processor.__key_speed);
      }
    } else if (e.keyCode === KEY_ENTER) {
      this.handleSave(processor);
    }
  },


  /**
   *
   * @param processor
   * @param {String|File|Blob} src
   */
  setImage: function setImage(processor, src) {
    if (typeof src !== 'string') {
      src = URL.createObjectURL(src);
    }
    this.UI.getImage(processor).src = src;
  },
  setQuality: function setQuality(processor, quality) {
    processor.setAttribute(this.Config.attrQuality, quality);
  },
  getQuality: function getQuality(processor) {
    var q = processor.getAttribute(this.Config.attrQuality);
    if (q) {
      q = parseFloat(q);
    } else {
      q = this.Config.defaultQuality;
    }
    return q;
  },
  setOutputSize: function setOutputSize(processor, size) {
    processor.setAttribute(this.Config.attrOutputSize, size);
  },
  getOutputSize: function getOutputSize(processor) {
    var s = processor.getAttribute(this.Config.attrOutputSize);
    if (s) {
      s = parseFloat(s);
    } else {
      s = this.Config.defaultOutputSize;
    }
    return s;
  },
  handleZoom: function handleZoom(processor, e) {
    e.preventDefault();
    var deltaX = -e.deltaY * 2;
    this.UI.resizeCursor(processor, deltaX);
  },
  handleImgLoad: function handleImgLoad(processor) {
    this.UI.centerCursor(processor);
    this.UI.getCursor(processor).focus();
  },
  setMoveStartPos: function setMoveStartPos(processor, e) {
    processor.__startX = e.layerX;
    processor.__startY = e.layerY;
  },
  getMoveStartPos: function getMoveStartPos(processor) {
    return [processor.__startX, processor.__startY];
  },
  handleMove: function handleMove(processor, e) {
    var startPos = this.getMoveStartPos(processor);
    var endX = e.layerX;
    var endY = e.layerY;
    var deltaX = endX - startPos[0];
    var deltaY = endY - startPos[1];
    this.UI.moveCursor(processor, deltaX, deltaY);
  },
  handleBeginMove: function handleBeginMove(processor, e) {
    var cursor = this.UI.getCursor(processor);
    cursor.focus();
    cursor.classList.add('moving');
    this.setMoveStartPos(processor, e);
    processor.__moving = addEvent(cursor, 'mousemove', this.handleMove.bind(this, processor));
  },
  handleEndMove: function handleEndMove(processor, e) {
    var cursor = this.UI.getCursor(processor);
    cursor.classList.remove('moving');
    delete removeEvent(cursor, 'mousemove', processor.__moving);
  },


  /**
   * Process an image - crops by selected region, resize to $size x $size
   * makes an image/jpeg with $quality
   * and returns a base64 string can be used in src attribute or for further custom file processing
   *
   * @param processor
   * @param size
   * @param quality
   * @returns {string}
   */
  processImage: function processImage(processor, size, quality) {
    var canv = BunnyImage.cropByCursor(this.UI.getImage(processor), this.UI.getCursor(processor));
    canv = BunnyImage.resizeCanvas(canv, size);
    var base64 = canv.toDataURL('image/jpeg', quality);
    return base64;
  },
  handleSave: function handleSave(processor) {
    var size = this.getOutputSize(processor);
    var quality = this.getQuality(processor);
    var src = this.processImage(processor, size, quality);
    if (processor.__on_save !== undefined) {
      processor.__on_save.forEach(function (cb) {
        cb(src);
      });
    }
  },
  onSave: function onSave(processor, callback) {
    if (processor.__on_save === undefined) processor.__on_save = [];
    processor.__on_save.push(callback);
  }
};

