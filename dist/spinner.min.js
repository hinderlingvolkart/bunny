
/**
 * SVG Spinner Component
 *
 * Creates inline <svg class="{className}"><use xlink:href="#{icon}"></svg>
 * and appends it to any 'element'
 *
 * Use Spinner.toggle(element) to add/remove spinner
 *
 * If `element` itself is an inline <svg>,
 *   then saves original icon ID
 *   and changes only xlink:href attribute
 *   instead of creating and appending new one <svg>
 *   Useful, for example, when search icon temporary could be replaced with spinner
 */

var SpinnerConfig = {

  icon: 'spinner',
  className: 'i-spinner', // class name with rotate animation since SVG SMIL is deprecated and is not working in IE/Edge

  tagNameFade: 'fade',
  classNameFade: null,
  classNameFadeShow: 'show',
  animationDuration: 600

};

var Spinner = {

  Config: SpinnerConfig,

  insertSpinner: function insertSpinner(element, spinner) {
    element.appendChild(spinner);
  },
  removeSpinner: function removeSpinner(element, spinner) {
    element.removeChild(spinner);
  },
  getSpinner: function getSpinner(element) {
    return element.__bunny_spinner || false;
  },
  has: function has(element) {
    return element.__bunny_spinner !== undefined;
  },
  show: function show(element) {
    var removeText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (element.tagName === 'SVG' || element.tagName === 'svg') {
      element.__bunny_spinner = getSvgIcon(element);
      changeSvgIcon(element, this.Config.icon);
      element.classList.add(this.Config.className);
    } else {
      if (removeText) {
        element.__bunny_spinner_text = element.innerHTML;
        element.textContent = '';
      }
      element.__bunny_spinner = createSvgUse(this.Config.icon, { class: this.Config.className });
      this.insertSpinner(element, element.__bunny_spinner);
    }
  },
  hide: function hide(element) {
    var removeText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (element.tagName === 'SVG' || element.tagName === 'svg') {
      element.classList.remove(this.Config.className);
      changeSvgIcon(element, element.__bunny_spinner);
    } else {
      this.removeSpinner(element, element.__bunny_spinner);
      if (removeText) {
        element.innerHTML = element.__bunny_spinner_text;
        delete element.__bunny_spinner_text;
      }
    }
    delete element.__bunny_spinner;
  },
  toggle: function toggle(element) {
    var removeText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (this.has(element)) {
      this.hide(element, removeText);
      return true;
    } else {
      this.show(element, removeText);
      return false;
    }
  },
  fadePage: function fadePage() {
    var _this = this;

    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var textClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    return new Promise(function (resolve) {
      var fade = _this.getFade();
      if (!fade) {
        var el = document.createElement(_this.Config.tagNameFade);
        if (_this.Config.classNameFade !== null) {
          el.classList.add(_this.Config.classNameFade);
        }
        var textNode = document.createElement('div');
        textNode.classList.add('fade');
        if (textClass) {
          textNode.classList.add(textClass);
        }
        el.appendChild(textNode);
        document.body.appendChild(el);
        setTimeout(function () {
          if (text !== null) {
            textNode.textContent = text;
            textNode.classList.add('in');
          }
          _this.toggle(el);
          el.classList.add(_this.Config.classNameFadeShow);
          setTimeout(function () {
            resolve();
          }, _this.Config.animationDuration);
        }, 0);
      } else {
        resolve();
      }
    });
  },
  getFade: function getFade() {
    return document.getElementsByTagName(this.Config.tagNameFade)[0] || false;
  },
  getFadeIcon: function getFadeIcon() {
    return this.getSpinner(this.getFade());
  },
  getFadeText: function getFadeText() {
    return this.getFade().getElementsByTagName('div')[0];
  },
  unfadePage: function unfadePage() {
    var _this2 = this;

    return new Promise(function (resolve) {
      var fade = _this2.getFade();
      if (fade) {
        fade.classList.remove(_this2.Config.classNameFadeShow);
        setTimeout(function () {
          document.body.removeChild(fade);
          resolve();
        }, _this2.Config.animationDuration);
      } else {
        resolve();
      }
    });
  },
  setFadeIcon: function setFadeIcon(newIconId) {
    var className = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    var spinner = this.getFadeIcon();
    spinner.classList.remove(this.Config.className);
    changeSvgIcon(spinner, newIconId);
    if (className) {
      spinner.classList.add(className);
    }
  },
  setFadeText: function setFadeText(newText) {
    var newClassAttribute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    var text = this.getFadeText();
    text.classList.remove('in');
    setTimeout(function () {
      text.textContent = newText;
      if (newClassAttribute) {
        text.setAttribute('class', newClassAttribute);
      }
      text.classList.add('in');
    }, 300);
  }
};

