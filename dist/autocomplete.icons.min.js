
// Polyfill for IE 9-11 classList on <svg> elements
if (Object.getOwnPropertyDescriptor(Element.prototype, 'classList') === undefined) {
  Object.defineProperty(Element.prototype, 'classList', Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'classList'));
}

var NAMESPACE_SVG = 'http://www.w3.org/2000/svg';
var NAMESPACE_XLINK = 'http://www.w3.org/1999/xlink';

/**
 * Document root <svg> with defs and icons
 */

function getRootSvg() {
  var childNodes = document.body.childNodes;
  var length = childNodes.length;
  for (var k = 0; k < length; k++) {
    var node = childNodes[k];
    if (node.tagName === 'svg' || node.tagName === 'SVG') {
      return node;
    }
  }
  return false;
}

function createRootSvg() {
  var svg = document.createElementNS(NAMESPACE_SVG, 'svg');
  svg.setAttribute('height', '0');
  document.body.appendChild(svg);
  return svg;
}

/**
 * SVG <use>, spites and icons
 */

function createSvgUse(iconId) {
  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var svg = document.createElementNS(NAMESPACE_SVG, 'svg');
  for (var attr in attributes) {
    svg.setAttribute(attr, attributes[attr]);
  }
  var use = document.createElementNS(NAMESPACE_SVG, 'use');
  use.setAttributeNS(NAMESPACE_XLINK, 'xlink:href', '#' + iconId);
  svg.appendChild(use);
  return svg;
}

function changeSvgIcon(svg, newIconId) {
  svg.firstChild.setAttributeNS(NAMESPACE_XLINK, 'xlink:href', '#' + newIconId);
}

function getSvgIcon(svg) {
  return svg.firstChild.getAttributeNS(NAMESPACE_XLINK, 'href').slice(1);
}

/**
 * SVG color matrix filter
 */

function rgbaToColorMatrix(red, green, blue) {
  var alpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  var decToFloat = function decToFloat(value) {
    return Math.round(value / 255 * 10) / 10;
  };
  var redFloat = decToFloat(red);
  var greenFloat = decToFloat(green);
  var blueFloat = decToFloat(blue);
  var alphaFloat = decToFloat(alpha);
  return '0 0 0 0 ' + redFloat + ' 0 0 0 0 ' + greenFloat + ' 0 0 0 0 ' + blueFloat + ' 0 0 0 1 ' + alphaFloat;
}

function getIdForSvgColorFilter(red, green, blue) {
  var alpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  return '__bunny_filter_' + red + '_' + green + '_' + blue + '_' + alpha;
}

function createOrGetSvgColorFilter(red, green, blue) {
  var alpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  var id = getIdForSvgColorFilter(red, green, blue, alpha);
  var rootSvg = getRootSvg();
  if (rootSvg === false) {
    rootSvg = createRootSvg();
  }
  if (!document.getElementById(id)) {
    var filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
    filter.setAttribute('id', id);
    filter.innerHTML = '<feColorMatrix type="matrix" values="' + rgbaToColorMatrix(red, green, blue, alpha) + '" />';
    rootSvg.appendChild(filter);
  }
  return id;
}

function applySvgColorFilterToElement(element, red, green, blue) {
  var alpha = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

  var id = createOrGetSvgColorFilter(red, green, blue, alpha);
  element.style.filter = 'url(#' + id + ')';
}

/**
 * SVG Spinner Component
 *
 * Creates inline <svg class="{className}"><use xlink:href="#{icon}"></svg>
 * and appends it to any 'element'
 *
 * Use Spinner.toggle(element) to add/remove spinner
 *
 * If `element` itself is an inline <svg>,
 *   then saves original icon ID
 *   and changes only xlink:href attribute
 *   instead of creating and appending new one <svg>
 *   Useful, for example, when search icon temporary could be replaced with spinner
 */

var SpinnerConfig = {

  icon: 'spinner',
  className: 'i-spinner', // class name with rotate animation since SVG SMIL is deprecated and is not working in IE/Edge

  tagNameFade: 'fade',
  classNameFade: null,
  classNameFadeShow: 'show',
  animationDuration: 600

};

var Spinner = {

  Config: SpinnerConfig,

  insertSpinner: function insertSpinner(element, spinner) {
    element.appendChild(spinner);
  },
  removeSpinner: function removeSpinner(element, spinner) {
    element.removeChild(spinner);
  },
  getSpinner: function getSpinner(element) {
    return element.__bunny_spinner || false;
  },
  has: function has(element) {
    return element.__bunny_spinner !== undefined;
  },
  show: function show(element) {
    var removeText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (element.tagName === 'SVG' || element.tagName === 'svg') {
      element.__bunny_spinner = getSvgIcon(element);
      changeSvgIcon(element, this.Config.icon);
      element.classList.add(this.Config.className);
    } else {
      if (removeText) {
        element.__bunny_spinner_text = element.innerHTML;
        element.textContent = '';
      }
      element.__bunny_spinner = createSvgUse(this.Config.icon, { class: this.Config.className });
      this.insertSpinner(element, element.__bunny_spinner);
    }
  },
  hide: function hide(element) {
    var removeText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (element.tagName === 'SVG' || element.tagName === 'svg') {
      element.classList.remove(this.Config.className);
      changeSvgIcon(element, element.__bunny_spinner);
    } else {
      this.removeSpinner(element, element.__bunny_spinner);
      if (removeText) {
        element.innerHTML = element.__bunny_spinner_text;
        delete element.__bunny_spinner_text;
      }
    }
    delete element.__bunny_spinner;
  },
  toggle: function toggle(element) {
    var removeText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (this.has(element)) {
      this.hide(element, removeText);
      return true;
    } else {
      this.show(element, removeText);
      return false;
    }
  },
  fadePage: function fadePage() {
    var _this = this;

    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var textClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    return new Promise(function (resolve) {
      var fade = _this.getFade();
      if (!fade) {
        var el = document.createElement(_this.Config.tagNameFade);
        if (_this.Config.classNameFade !== null) {
          el.classList.add(_this.Config.classNameFade);
        }
        var textNode = document.createElement('div');
        textNode.classList.add('fade');
        if (textClass) {
          textNode.classList.add(textClass);
        }
        el.appendChild(textNode);
        document.body.appendChild(el);
        setTimeout(function () {
          if (text !== null) {
            textNode.textContent = text;
            textNode.classList.add('in');
          }
          _this.toggle(el);
          el.classList.add(_this.Config.classNameFadeShow);
          setTimeout(function () {
            resolve();
          }, _this.Config.animationDuration);
        }, 0);
      } else {
        resolve();
      }
    });
  },
  getFade: function getFade() {
    return document.getElementsByTagName(this.Config.tagNameFade)[0] || false;
  },
  getFadeIcon: function getFadeIcon() {
    return this.getSpinner(this.getFade());
  },
  getFadeText: function getFadeText() {
    return this.getFade().getElementsByTagName('div')[0];
  },
  unfadePage: function unfadePage() {
    var _this2 = this;

    return new Promise(function (resolve) {
      var fade = _this2.getFade();
      if (fade) {
        fade.classList.remove(_this2.Config.classNameFadeShow);
        setTimeout(function () {
          document.body.removeChild(fade);
          resolve();
        }, _this2.Config.animationDuration);
      } else {
        resolve();
      }
    });
  },
  setFadeIcon: function setFadeIcon(newIconId) {
    var className = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    var spinner = this.getFadeIcon();
    spinner.classList.remove(this.Config.className);
    changeSvgIcon(spinner, newIconId);
    if (className) {
      spinner.classList.add(className);
    }
  },
  setFadeText: function setFadeText(newText) {
    var newClassAttribute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    var text = this.getFadeText();
    text.classList.remove('in');
    setTimeout(function () {
      text.textContent = newText;
      if (newClassAttribute) {
        text.setAttribute('class', newClassAttribute);
      }
      text.classList.add('in');
    }, 300);
  }
};

Object.assign(AutocompleteConfig, {
  iconSearch: 'search' // default inline svg icon ID to display
});

Object.assign(AutocompleteUI, {
  getIcon: function getIcon(autocomplete) {
    return autocomplete.getElementsByTagName('svg')[0];
  },
  createIcon: function createIcon() {
    return createSvgUse(this.Config.iconSearch);
  },
  insertIcon: function insertIcon(autocomplete, icon) {
    autocomplete.appendChild(icon);
  }
});

Object.assign(Autocomplete, {
  initIcons: function initIcons(autocomplete) {
    var _this = this;

    var icon = this.UI.createIcon();
    this.UI.insertIcon(autocomplete, icon);
    this.onBeforeUpdate(autocomplete, function () {
      _this.showSpinner(autocomplete);
    });
    this.onUpdate(autocomplete, function (res, err) {
      _this.hideSpinner(autocomplete);
    });
  },
  showSpinner: function showSpinner(autocomplete) {
    Spinner.toggle(this.UI.getIcon(autocomplete));
  },
  hideSpinner: function hideSpinner(autocomplete) {
    Spinner.toggle(this.UI.getIcon(autocomplete));
  }
});
