
var ApiConfig = {
  prefix: '/ajax',
  headers: {
    'Accept': 'application/json',
    'X-Requested-With': 'XMLHttpRequest'
  },
  credentials: 'same-origin', // fetch Request credential option to send cookies
  redirectDelay: 2000 // if server returned data.redirect, redirect to that URL after redirectDelay ms.
};

var Api = {

  Config: ApiConfig,

  prefix: '',

  request: function request(url) {
    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'GET';
    var body = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var additionalHeaders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    var _this = this;

    var responseType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'json';
    var useGlobalHeaders = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;

    var req = this.createRequest(url, method, body, additionalHeaders, responseType, useGlobalHeaders);
    return fetch(req).then(function (response) {
      if (response.status === 200) {
        return response[responseType]();
      } else {
        return _this.onStatusFail(response);
      }
    }).then(function (data) {
      return _this.onResponse(data);
    }).catch(function (response) {
      return _this.onError(response, _this.createUrl(url), method);
    });
  },
  createRequest: function createRequest(url) {
    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'GET';
    var body = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var additionalHeaders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var responseType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'json';
    var useGlobalHeaders = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;

    var headers = this.createHeaders(additionalHeaders, useGlobalHeaders);
    var initObj = { method: method, headers: headers, credentials: this.Config.credentials };
    if (body !== null) {
      initObj.body = body;
    }
    return new Request(this.createUrl(url), initObj);
  },
  createHeaders: function createHeaders() {
    var additionalHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var useGlobalHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    var headers = {};
    if (useGlobalHeaders) {
      headers = Object.assign({}, this.Config.headers, additionalHeaders);
    } else {
      headers = additionalHeaders;
    }
    return new Headers(headers);
  },
  createUrl: function createUrl(url) {
    return url.indexOf('://') > -1 ? url : this.Config.prefix + this.prefix + url;
  },
  get: function get(url) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var additionalHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var queryStr = '';
    if (params !== null) {
      queryStr = '?' + Object.keys(params).map(function (k) {
        return encodeURIComponent(k) + '=' + encodeURIComponent(params[k]);
      }).join('&');
    }
    return this.request(url + queryStr, 'GET', null, additionalHeaders);
  },
  createFormData: function createFormData(data) {
    if (data instanceof FormData) {
      return data;
    }
    var formData = new FormData();
    for (var key in data) {
      formData.append(key, data[key]);
    }
    return formData;
  },
  post: function post(url, data) {
    var additionalHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    return this.request(url, 'POST', this.createFormData(data), additionalHeaders);
  },


  // data is root object returned by server and not just inner data key
  onResponse: function onResponse(data) {
    if (data.message) {
      this.showStatusWarning(data.message);
    } else if (data.success) {
      this.showStatusSuccess(data.success);
    }
    this.attemptRedirect(data);
    return data;
  },
  onError: function onError(response, url, method) {
    var error = response.status + ' (' + response.statusText + ')';
    console.error('Api call error:\n  URL: ' + url + '\n  Method: ' + method + '\n  Status: ' + error);
    return Promise.reject(response);
  },
  onRequestEntityTooLarge: function onRequestEntityTooLarge() {
    this.showStatusError('413: Request entity too large!');
  },
  onStatusNotFound: function onStatusNotFound() {
    this.showStatusError('404: API Route not found!');
  },
  onStatusAccessDenied: function onStatusAccessDenied() {
    this.showStatusError('403: Access denied!');
  },
  onStatusUnauthorized: function onStatusUnauthorized() {
    this.showStatusError('401: You are not logged in!');
  },
  onStatusServerError: function onStatusServerError() {
    this.showStatusError('500: Server error!');
  },
  onStatusFail: function onStatusFail(response) {
    var status = response.status;
    var methodName = 'onStatus' + status;
    if (this[methodName] !== undefined) {
      this[methodName](response);
    } else if (status === 413) {
      this.onRequestEntityTooLarge();
    } else if (status === 404) {
      this.onStatusNotFound();
    } else if (status === 403) {
      this.onStatusAccessDenied();
    } else if (status === 401) {
      this.onStatusUnauthorized();
    } else if (status === 500) {
      this.onStatusServerError();
    }
    return Promise.reject(response);
  },
  showStatusError: function showStatusError(message) {
    var autoRemoveAfter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Notify.Config.autoRemoveAfter;

    Notify.danger(message, autoRemoveAfter);
  },
  showStatusWarning: function showStatusWarning(message) {
    var autoRemoveAfter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Notify.Config.autoRemoveAfter;

    Notify.warning(message, autoRemoveAfter);
  },
  showStatusSuccess: function showStatusSuccess(message) {
    var autoRemoveAfter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Notify.Config.autoRemoveAfter;

    Notify.success(message, autoRemoveAfter);
  },


  // for redirect back in browser history, server should provide redirectback key
  // if redirect back in browser was not possible, will refresh page or if redirect key was provided as well, redirect to it instead
  // othwerwise refreshes page if redirect key is provided and is empty string or redirects to provided URL
  attemptRedirect: function attemptRedirect(data) {
    var f = null;
    if (data.redirectback !== undefined) {
      if (document.referrer !== '') {
        f = function f() {
          location.href = document.referrer;
        };
      } else if (data.redirect === undefined || data.redirect === '') {
        f = function f() {
          return location.reload();
        };
      } else {
        f = function f() {
          location.href = data.redirect;
        };
      }
    } else if (data.redirect !== undefined) {
      if (data.redirect === '') {
        f = function f() {
          return location.reload();
        };
      } else {
        f = function f() {
          location.href = data.redirect;
        };
      }
    }
    if (f !== null) {
      setTimeout(f, this.Config.redirectDelay);
    }
  }
};

